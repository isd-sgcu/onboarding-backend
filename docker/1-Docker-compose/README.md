### Configuration

- you use a single `YAML` file to configure and maintain your application's services
- With a **Single command**, you create and start all the services from your configuration
- Declarative definition

Dockerfile

```sh
# Start mongodb
docker run -d \
-p 27017:27017 \
-e MONGO_INITDB_ROOT_USERNAME=admin \
-e MONGO_INITDB_ROOT_PASSWORD=password \
--net mongo-network \
--name mongodb \
mongo
```

if you have multiple services, you have to run so many docker container.
The docker compose will help you run all of them in one command

docker-compose.yaml

```yaml
version: '3.1' # version of docker-compose

services: #
	mongodb: # container name
		image: mongo:5.6 # docker image
		# build: . # you can build your own docker image by specif
		ports:
		 - 27017:27017 # <host>:<container>
		environment:
		- MONGO_INITDB_ROOT_USERNAME=admin
		- MONGO_INITDB_ROOT_PASSWORD=password
	mongo-express:
		image: mongo-express
		ports:
		- 8081:8081
		environment:
		- ME_CONFIG_MONGODB_ADMINUSERNAME=admin
		- ME_CONFIG_MONGODB_ADMINPASSWORD=password
		- ME_CONFIG_MONGODB_SERVER=mongodb
```

- Helps to structure your command
- Simplifies container management
- Easier to make changes, and see current configuration
- Declarative approach: defining the desired state

- By default, ==Compose sets up a single network== for your app
- Communication via container name
- But option to specify your own networks with the top-level `networks` key

Run docker compose with detach mode: it **start the containers** in the **background** and leaves them running

```sh
docker compose up -d
```

You want to **stop** and **re-start** the containers only

```sh
docker compose -f <docker-compose-file> stop
```

When you remove container

- By default, **no persistence**
- All data is gone, when containers are removed
  - you can check `docker compose -f <docker-compose-file> start`
- ==Volumes== are the mechanism for persisting data generated by and used by containers

Rewrite container name

```sh
docker compose --project-name <projct-name> ...
```

---

**Variable in docker compose**

- ==DO NOT== hardcode any sensitive data
- Anything that is pushed to remote Git repository will stay in the Git history

```yaml
version: '3.1' # version of docker-compose

services: #
	mongodb: # container name
		image: mongo:5.6
		ports:
		 - 27017:27017 # <host>:<container>
		environment:
		- MONGO_INITDB_ROOT_USERNAME=${MONGO_ADMIN_USER}
		- MONGO_INITDB_ROOT_PASSWORD=${MONGO_ADMIN_PASSWORD}
	mongo-express:
		image: mongo-express
		ports:
		- 8081:8081
		environment:
		- ME_CONFIG_MONGODB_ADMINUSERNAME=${MONGO_ADMIN_USER}
		- ME_CONFIG_MONGODB_ADMINPASSWORD=${MONGO_ADMIN_PASSWORD}
		- ME_CONFIG_MONGODB_SERVER=${MONGO_DB_SERVER}
```

**How to run it ?**

```sh
docker-compose up  # run the docker-compose.yaml
docker-compose up -d # run the docker-compose.yaml in detach mode
docker-compose down # stop the docker-compose.yaml
```

Then it should

1. build docker image
2. start container

- With environment variables there is still a **risk of unintentional information exposure**
- Use **Secrets** is an even better way to use secrets without having to use environment variables

```yaml
services:
	myapp:
		image: myapp:latest
		secrets:
			- my_secret

secrets:
	my_secret:
		file: ./my_secret.txt
```

---

**Use image from private repository**

- Run app on Deployment Server -> Pull from **public Docker Hub repository**

```sh
docker build -t macgeargear/<repo>:1.0 .
```

When you need to `push` or `pull` from docker, you need to login

```sh
docker login
```

---

**Main Use Case of Docker Compose**

- To define and manage services (containers) that make up your app
- So they can be run together in an isolated environment

**Limitations** of Docker compose

- A **lot of operational effort** to run containers on a large scale
  **Kubernetes** will have
- manage **large-scale** apps and containers deployed **across multiple nodes**
- auto-scaling
- self-healing

---

# Best practice

### Use Official Docker Image as Base Image

❎DONT❎

```Dockerfile
# Base operating system image
FROM ubuntu

# Install packages by yourself
RUN apt-get update && apt-get install -y \
	node \
	&& rm -rf /var/lib/apt/lists/*
```

✅DO✅

- Use **Official** `node` image as base image

```Dockerfile
FROM node
```

### Use Specific Docker Image Versions

```Dockerfile
FROM node:18.0.1
```

- if you use just `FROM node`, it will use the **latest tag**
  - `FROM node` == `FROM node:latest`
- Why is this bad ?
  - You might get different docker image versions
  - Might break stuff
  - ==latest tag is unpredictable==

### Use Small-Sized Official Images

Does it matter ?

- Many OS features your image will never use
- Have **Smaller** Images means
  - Less storage space in Image Repository and Server
  - Transfer Images faster
- **Leaner** Operating System Distro - Only bundle necessary utilities
  ❎DONT❎
- Could be based on full-blown OS

```Dockerfile
FROM node:17.0.1
```

✅DO✅

- Use Image based on a **leaner and smaller OS distro**

```Dockerfile
FROM node:17.0.1-alpine
```

**Alpine Linux**

- lightweight Linux distro
- security-oriented

### Optimize Caching Image Layers

What are **Image Layers?** and **Caching an Image Layer** ?

- Docker Images are build based on a **Dockerfile**
- ==Each command creates and image layer==

```Dockerfile
FROM node:17.0.1-alpine

WORKDIR /app

COPY myapp /app

RUN npm install --production

CMD ["node", "src/index.js"]
```

What does **Caching** an **Image Layer?**

- Docker caches each layer, saved on local filesystem

---

Example of docker-compose using in previous project

```yaml
version: "3.9"

services:
  local-auth:
    image: ghcr.io/isd-sgcu/johnjud-auth
    container_name: auth
    depends_on:
      - local-db
      - local-cache
    restart: unless-stopped
    networks:
      - johnjud-local
      - database
    volumes:
      - ./config/auth:/app/config
    ports:
      - "3002:3002"

  local-backend:
    image: ghcr.io/isd-sgcu/johnjud-backend
    container_name: backend
    depends_on:
      - local-db
      - local-cache
    restart: unless-stopped
    networks:
      - johnjud-local
      - database
    volumes:
      - ./config/backend:/app/config
    ports:
      - "3003:3003"

  local-file:
    image: ghcr.io/isd-sgcu/johnjud-file
    container_name: file
    depends_on:
      - local-db
      - local-cache
    restart: unless-stopped
    networks:
      - johnjud-local
      - database
    volumes:
      - ./config/file:/app/config
    ports:
      - "3004:3004"

  local-db:
    image: postgres:15.1-alpine3.17
    container_name: local-db
    restart: unless-stopped
    environment:
      POSTGRES_USER: root
      POSTGRES_PASSWORD: root
      POSTGRES_DB: johnjud_db
    networks:
      - database
    volumes:
      - ./volumes/postgres:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  local-cache:
    image: redis:7.2.3-alpine
    container_name: local-cache
    restart: unless-stopped
    environment:
      REDIS_HOST: localhost
      ALLOW_EMPTY_PASSWORD: "yes"
    networks:
      - database
    ports:
      - "6379:6379"

networks: # by default docker compose create default network you and define custom network here
  johnjud-local:
    name: johnjud-local
  database:
    name: database
```
